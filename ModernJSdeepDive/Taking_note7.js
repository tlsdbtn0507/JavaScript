//
//8 함수
//
"use strict";

//8-1 함수란?
//프로그래밍에서 함수란 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것

function add(x, y) {
  return x + y;
}

add(2, 5); //=>7
//함수 내부로 입력을 전달받는 변수가 매개변수/ 입력은 인수/ 출력은 반환값
//함수는 함수 정의를 통해 생성
//함수정의 ex)
function add(x, y) {
  return x + y;
}
//함수는 정의만으로 실행되는 것이 아니라 인수를 매개변수를 통해 함수에 전달하며 함수를 실행
//=> 함수 호출이라 한다
//함수호출ex)
var result = add(2, 7);
console.log(result);
//8-2 함수를 사용하는 이유
//코드의 재사용 측면과 유지보수의 편의성을 높이고 코드의 신뢰성을 높이며 코드의 가독성 향상

//8-3 함수 리터럴
//js에서 함수는 객체 타입의 값이므로 함수도 함수리터럴로 생성 할 수 있다
var f = function add(x, y) {
  return x + y;
};
//함수는 객체다 함수는 객체다 함수는 객체다 함수는 객체다 함수는 객체다
//함수는 다른 일반 객체와는 다르게 호출할 수 있따

//8-4 함수 정의
//함수를 정의하는데 4가지 방법이 있따

//1 함수 선언
function add(x, y) {
  return x + y;
}
//2 함수 표현식
var f = function add(x, y) {
  return x + y;
};
//3 function 생성자 함수
var add = new Function("x", "y", "return x+y");

//4 arrow function
var add = (x, y) => x + y;

//*참고* 변수는 '선언'하고 함수는 '정의'한다

//8-4-1 함수선언문
function add(x, y) {
  return x + y;
}
//해당 함수 호출 법
console.log(add(2, 5)); // => 7
//함수 선언문은 함수 이름을 생략할 수 없다
// function (x, y) {
//   return x + y;
// } => Syntax Error

//함수 선언문은 표현식이 아닌 문이다
var add = function add(x, y) {
  return x + y;
};
// 위 문을 보면 함수 선언문이 변수에 할당 되는 것 처럼 보이지만 js엔진이 코드 문맥에 따라 함수 리터럴을 함수 선언문으로 해석하는 경우와
//함수 리터럴 표현식으로 해석하는 경우가 있기 때문
//자바스크립트엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고
//거기에 함수 객체를 할당한다. 함수는 함수 이름으로 호출하는 것이 아닌 함수 객체를 가리키는 시별자로 호출함

//var옆에 add는 식별자 function옆에 add는 함수 이름
var add = function add(x, y) {
  return x + y;
};
//콘솔로그 되는 add는 식별자
console.log(add(2, 4));

//8-4-2 함수 표현식
//자바스크립트의 함수는 값의 성질을 갖는 객체인 일급 객체이다 그러므로 함수는 함수 리터럴로 생성한 함수 객체를
//변수에 할당 할수 있다.이러한 방식을 함수 표현식이라고 한다
var add = function (x, y) {
  return x + y;
};
console.log(add(2, 6));

//함수 리터럴의 함수이름은 생략 가능하고 그를 익명 함수라고 한다
//기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};
console.log(foo(2, 3)); //=> Syntax Error foo is not defined

//8-4-3 함수 생성 시점과 함수 호이스팅

console.dir(add); //=> f add(x,y)
console.dir(sub); //=> undefined

console.log(add(2, 5)); //=> 7
console.log(sub(2, 5)); //=> Type Error: sub is not a function

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
//함수 선언문으로 정의한 함수(add)와 함수 표현식으로 정의한 함수(sub)의 생성 시점은 다르다
//함수는 호이스팅으로 인해 함수 선언문이 코드의 선두로 끌어 올려져 런타임 이전 js 엔진에 의해 먼저 실행된다
//그래서 함수 선언문(add)보다 이전에 함수를 참조해도 싫행이 가능하다

//함수와 변수 호이스팅은 미묘한 차이가 있는데
//변수는 undefined로 초기화 되고 함수 선언문의 식별자는 함수 객체로 초기화 된다

//함수 표현식은 변수에 할당 되는 값이 함수 리터럴인 문이다 그래서 변수 선언문과 변수 할당문을 한번에 동작시킨 것과
//같이 동작한다
// 따라서 함수표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다

//8-4-4 function 생성자 함수
//*생성자 함수*: 객체를 생성하는 함수
var add = new Function("x", "y", "return x+y");
//이는 일반적이지도 않고 바람직한 함수 생성방식이 아니므로 이런게 있다 정도로만 알자

//8-4-5 화살표 함수
//function 키워드 대신 arrow =>를 사용하는 방식
const add = (x, y) => x + y;
console.log(add(2, 1)); //=> 3
//이는 기존의 함수보다 표현만 간략한것이 아닌 내부 동작도 간략화 되어 있고 생성자 함수를 쓸수 없고 기존의 this바인딩과 방식도 다르다
//prototype 프로퍼티가 없으며 argument객체 또한 생성x

//8-5 함수호출
//함수는 함수() 방식으로 호출하고 ()안에 인수는 쉼표로 구분해서 나열한다
//함수를 호출하면 현재의 실행흐름을 중단하고 호출된 함수로 실행 흐름을 옮김
//그때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행

//8-5-1 매개변수와 인수
//함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 때 매개변수를 통해 인수를 전달함
//인수는 함수를 호출할때 지정하고 개수와 타입엔 제한이 없다
//매개변수는 함수 몸체 내부에서만 참조 가능하고 외부에선 참조 x
//또한 함수는 매개변수와 인수의 개수가 일치하는지 체크하지 않음 만약 인수의 개수가 부족해서 할당 되지않은 매개변수의 값은 undefined이다
//그렇다고 초과된 인수를 그냥 버리진 않음

//8-5-2 인수확인
//함수를 정의할 때 적절한 인수가 전달되었는지 확인 해야 오류를 예측할 수 있다
//하지만 ES6에 도입된 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화 할 수 있따.
//ex)

function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}
console.log(add(1, 2, 3)); //6
console.log(add(1, 2)); //3
console.log(add(1)); //1
console.log(add()); //0

//8-5-3 매개변수의 최대 개수
//매개변수는 순서에 의미가 있어서 매개변수가 많아지면 함수 호출 시 인수의 순서를 고려해야한다 이는 함수의 사용법을 어렵게 만들고
//이는 곧 코드의 유지 보수성을 악화시킨다 고로 이상적인 함수는 한가지 일만 해야하고 가급적 작게 만들어야 한다
//그러므로 매개 변수도 최대 3개이상을 넘지 않도록 하는 것이 좋다
//만약 인수로 객체를 사용하면 매개변수의 순서나 코드의 가독성이 좋아지지만 전달된 객체를 함수 내부에서 변경하면 함수 외부에 있는
//객체가 변경되는, 부수효과가 발생한다

//8-5-5 반환문
//return키워드로 함수의 실행결과를 함수 외부로 반환한다
//이는 두가지 역할을 하는데
//1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다 고로 반환문 이후 문은 실행하지 않음
//2. 반환문은 return뒤의 표현식을 평가하기에 그 표현식을 명시적으로 지정하지 않으면 undefined
//반환문은 생략 할수 도 있고 return과 표현식 하이에 줄바꿈을 하면 예상치 못할 오류가 발생 할수 있어서 줄바꿈 x
//그리고 반환문은 함수 몸체 안에서만 쓸 수 있어서 함수 외부 전역에 쓰면 문법에러 발생

//8-6 참조에 의한 전달과 외부 상태의 변경
//객체 타입 인수는 원시값과 다르게 함수 몸체나 다른 참조 값을 통해서 객체를 변경하면 원본이 훼손된다. 즉 함수 외부에서 함수 몸체
//내부로 전달한 참조값에 의해 원본 객체가 변경되는 부수 효과가 발생한다
//이를 방지 하기 위한 방법으론 객체를 불변객체로 만들어서 변경 불가능한 값으로 만들거나
//객체릐 방어적 복사 혹은 깊은 복사를 통한 교체로 외부 상태가 변경되는 부수효과를 없앨 수 있다

//8-7 다양한 함수의 형태
//8-7-1 즉시 실행 함수
//즉시 실행 함수는 단한번만 호출되며 다시 호출할 수 없고 보통 익명함수를 사용하는 것이 일반적이며 반드시 그룹연산자(...)로 감싸야함
//그룹 연산자로 묶는 이유는 함수 리터럴을 평가해서 함수 객체를 생성하기 위함이다
//즉시 실행 함수도 일반 함수 처럼 값을 반환 할 수 있고 인수를 전달 할수도 있음
let res = (function () {
  var a = 3;
  var b = 3;
  return a + b;
})();
console.log(res); //=>9

res = (function (a, b) {
  return a * b;
})(3, 5);
console.log(res); //=>15

//8-7-2 재귀 함수
//함수가 자기 자신을 호출하는 것을 재귀 호출이라 하고 재귀 함수는 재귀 호출을 수행하는 함수이다
//그리고 이는 반복되는 처리를 위해 사용한다
function countDown(n) {
  for (let i = n; i >= onabort; i++) console.log(i);
}
countDown(10); //=> 10부터 0까지 출력하는 함수인데 이를 재귀 함수를 이용하면

function countDown(n) {
  if (n < 0) return;
  console.log(n);
  countDown(n - 1); // 이 부분이 재귀 호출
}
countDown(10); //위 문과 똑같이 실행
// 재귀함수를 이용하면 1부터 자신까지의 모든 양의 정수를 곱하는 팩토리얼 같이 귀찮은 작업을 간단히 구현할 수 있다

function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // => 이 부분이 재귀 호출
}
console.log(factorial(5)); // =>120
//재귀 함수는 자신을 무한 재귀 호출하기에 무조건 탈출조건을 만들어줘야 한다

//8-7-3 중첩 함수
//함수 내부에 정의된 함수를 중첩 혹은 내부 함수라고 한다 그리고 중첩 함수를 포함하는 함수는 외부 함수라고 한다
//중첩은 외부 함수 내에서만 호출 할수 있고 보통 중첩은 자신을 포함한 외부를 돕는 헬퍼 함수의 역할을 한다

//8-7-4 콜백 함수
// 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달 받은
//함수를 고차 함수라고 한다 중첩함수가 외부 함수를 돕는 헬퍼함수의 역할을 하는 것 처럼 콜백도 고차에 전달 된어 헬퍼 역할을 한다
//단 중첩 함수는 고정되어서 교체하기 곤란하지만 콜백은 함수 외부에서 고차 내부로 주입하기 때문에 자유롭게 교체 할수 있다
//고차 함수는 콜백을 자신의 일부분으로 함성하고 매개변수를 통해 전달받은 콜백의 호출시점을 결정하고 호출하며
//콜백은 고차에 의해 호출되고 그때 고차는 필요에 따라 콜백에 인수를 전달 할수있다
//이는 함수형 프로그래밍 뿐만 아니라 비동기 처리(이벤트, ajax통신, 타이머 함수 등)에 활용되는 중요한 패턴이다 또한
//배열 고차 함수에서도 사용되는데 JS에서 배열은 사용빈도가 매우 높고 배열을 다룰때 배열 고차 함수는 매우 중요하다

//8-7-5 순수 함수와 비순수 함수
//함수형 프로그래밍에서 어떠한 외부상태에 의존하거나 변경하지 않는, 부수 효과가 없는 함수를 순수 함수라고 하고
//그 반대를 비순수 함수라고 한다
//순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하고 일반적으로 최소 하나 이상의 인수를 전달 받는다 그리고 이 함수의
//또다른 특징은 함수의 외부 상태를 변경하지 않는다

var count = 0;
//순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값 반환
function increase(n) {
  return n++;
}
count = increase(count);
console.log(count); //1
count = increase(count);
console.log(count); //2

var count = 0;
//비순수 함수
function increase() {
  return ++count;
}
//비순수 함수는 외부 상태(count)를 변경하므로 상태 변화 추척이 어렵다
increase();
console.log(count); //1
increase();
console.log(count); //2

//
//13 스코프
//

//13-1 스코프란?
//스코프는 우리말로 유효범위로 모든 프로그래밍 언어의 기본이며 중요한 개념이다 근데 JS의 스코프는 다른 언어의 것과는
//구별되는 특징이 주의가 필요하다 그리고 var let const로 선언한 변수의 스코프도 다르게 동작한다
//모든 식별자(변수, 함수, 클래스의 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조 할 수 있는 유효범위가 결정되고
//이를 스코프라고 하며 식별자가 유효한 범위라고 할 수 있다.

//13-2 스코프의 종류
//전역과 지역으로 나눌 수 있따

//13-2-1 전역과 전역스코프
//전역이란 코드의 가장 바깥 영역이고 전역 스코프를 만들며 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 되고 전역변수는
//어디서든 (함수내부에서도) 참조 할 수 있다.

//13-2-2 지역과 지역스코프
//지역은 함수 몸체 내부를 말하고 지역은 지역스코프를 만든다 지역 변수는 자신의 지역 스코프와 하위지역 스코프에서 유효하다
//지역 변수는 지역에서만 써야하고 전역에서 쓰면 에러

//13-3 스코프 체인
//함수 내부에 함수가 정의된 것을 '함수의 중첩'이라고 한다. 그리고 함수 몸체 내부에서 정의한 함수를 중첩함수, 중첩함수를
//포함하는 함수를 외부함수라고 한다
//함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩되어 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다고 볼 수 있다.
//그때 외부함수의 지역 스코프를 중첩 함수의 상위 스코프라고 한다

var x = "global x";

function outer() {
  var z = "outer's local z";

  function inner() {
    var x = "inner's local x";
  }
  inner();
}
outer();

console.log(x); //=>  "global x"
console.log(z); //=> x is not defined
//여기서 inner는 outer의 중첩함수이고 outer함수의 지역 스코프는 inner의 상위 스코프이고 outer함수의 상위 스코프는 전역 스코프이다
//모든 지역 스코프의 최 상위 스코프는 전역 스코프이고 이렇게 스코프들이 계층적으로 연결된 것을 스코프체인이라고 한다

//변수를 참조할 때 JS엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다
//*렉시컬 환경이란?* 스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이고 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은
//함수가 호출되면 바로 생성됨

//13-3-1 스코프 체인에 의한 변수 검색
//상위에 유효한 변수는 하위에서도 자유롭게 참조 할 수 있지만 하위에 유효한 변수는 상위에서 자유롭지 않다

//13-3-2 스코프 체인에 의한 함수 검색
//함수도 식별자에 할당 되기 때문에 스코프를 갖고 식별자에 함수객체가 할당된 것 외에는 일반 변수와 다를 바 없다.
//그러므로 스코프를 식별자를 검색하는 규칙이라고 표현하는 것이 좋다

//13-4 함수 레벨 스코프
//코드 블록이 아닌 함수에 의해서만 지역스코프가 생성된다 모든 코드블록이 지역 스코프를 만들고 이러한 특성을 블록 레벨 스코프라고 한다
//하지만 var로 선언된 변수들은 무조건 함수의 코드블록만 지역스코프라고 인정해서
var x = 1;
if (true) {
  var x = 10;
}
console.log(x);
//위의 식 결과를 10이라고 선언하는 부작용이 있다.
//반대로 let const는 블록레벨 스코프를 지원해서 위의 문이 실행되지 않는다

//13-5 렉시컬 스코프
//JS는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다
//함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향을 주지 않고 함수의 상위 스코프는 언제나 자신이 정의된 스코프이다
//함수 정의가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억하고 함수가 실행 될때 정적으로 결정된다
var x = 1;
function foo() {
  var x = 10;
  bar();
}
function bar() {
  console.log(x);
}

foo();
bar();
//이 예제의 bar함수는 전역에서 정의됐고 전역 코드가 실행되기 전에 먼저 평가되어 함수객체를 생성한다 이때 bar함수는 전역 스코프를 기억하고
//그 함수가 호출되면 호출된 곳이 어디인지 상관없이 자신이 기억한 전역 스코프를 상위 스코프로 사용해서 foo(), bar()모두 1을 출력한다

//
//14 전역변수의 문제점
//

//14-1 변수의 생명주기
//14-1-1 지역 변수의 생명 주기
//변수는 생성되고 소멸하는 생명 주기가 있고 자신이 선언된 위치에서 생성되고 소멸한다
//일례로 전역 변수의 생명주기는 애플리케이션의 생명주기와 같다 하지만 지역 변수는 함수가 호출되면 생성되고 종료하면 따라서 소멸한다
function foo() {
  var x = local;
  return x;
}
foo();
console.log(x); //=> x is not defined

var x = "global";
function foo() {
  console.log(x); // => x is not defined 그 이유는 변수x는 선언 이전 이고 함수 몸체에 있는 지역 변수이기에 전역변수를 참조 하지 않는다
  var x = "local";
}

//14-1-2 전역 변수의 생명주기
//함수와 달리 전역코드는 명시적인 호출 없이 실행되며 var키워드로선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다

//14-2 전역변수의 문제점
//1. 암묵적 결합: 모든 코드가 전역 변수를 참조 하고 변경 할 수 있는 암묵적 결합을 허용한다
//2. 긴 생명주기: 전역 변수는 생명주기가 길어서 메모리 리소스도 오래 소비하고 전연 변수의 상태를 변경할 시간과 기회가 많다
//3. 스코프 체인 상에서 종점에 존재: 전역 변수는 스코프 체인 상 종점에 존재해서 가장 마지막에 검색되어 검색속도가 가장 느리다
//4. 네임스페이스 오염: JS의 가장 큰 문제중 하나가 파일이 분리돼있어도 하나의 전역스코프를 공유해서 예상치 못한 결과를 낼 수도 있따

//14-3 전역변수의 사용 억제법
//반드시 전역으로 쓸거 아니면 지역으로 써야하고 변수의 스코프는 좁을 수록 좋다
//1. 즉시 실행함수: 모든 코드를 즉시 실행 함수로 감사면 모든 변수는 즉시 실행 함수의 지역변수가 된다 /이 방법은 전역 변수를 생성하지 않아 라이브러리등에 자주쓰인다
//2. 네임 스페이스 객체: 이름 공간을 따루 나누는 건데 식별자 충돌을 방지 할수 있으나 네임스페이스 자체가 전역 변수라 그다지 추천 x
//3. 모둘 패턴: 모듈패턴은 JS의 강력한 기능인 클로저를 기반한 동작으로 전역 변수의 억제는 물론 캡슐화 까지 구현 할 수 있다
//캡슐화란 객체의 상태를 나타내는 프로퍼티와 그를 참조하고 조작하는 메서드를 하나로 묶는다 이는 보통 객체의 특정 정보를 감추기 위한 정보 은닉을 위해 쓴다.
//4. ES6모듈: ES6모듈을 쓰면 더이상 전역 변수를 쓸수 없다
