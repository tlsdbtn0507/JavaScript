//
//8 함수
//
"use strict";

//8-1 함수란?
//프로그래밍에서 함수란 일련의 과정을 문으로 구현하고 코드블록으로 감싸서 하나의 실행 단위로 정의한 것

function add(x, y) {
  return x + y;
}

add(2, 5); //=>7
//함수 내부로 입력을 전달받는 변수가 매개변수/ 입력은 인수/ 출력은 반환값
//함수는 함수 정의를 통해 생성
//함수정의 ex)
function add(x, y) {
  return x + y;
}
//함수는 정의만으로 실행되는 것이 아니라 인수를 매개변수를 통해 함수에 전달하며 함수를 실행
//=> 함수 호출이라 한다
//함수호출ex)
var result = add(2, 7);
console.log(result);
//8-2 함수를 사용하는 이유
//코드의 재사용 측면과 유지보수의 편의성을 높이고 코드의 신뢰성을 높이며 코드의 가독성 향상

//8-3 함수 리터럴
//js에서 함수는 객체 타입의 값이므로 함수도 함수리터럴로 생성 할 수 있다
var f = function add(x, y) {
  return x + y;
};
//함수는 객체다 함수는 객체다 함수는 객체다 함수는 객체다 함수는 객체다
//함수는 다른 일반 객체와는 다르게 호출할 수 있따

//8-4 함수 정의
//함수를 정의하는데 4가지 방법이 있따

//1 함수 선언
function add(x, y) {
  return x + y;
}
//2 함수 표현식
var f = function add(x, y) {
  return x + y;
};
//3 function 생성자 함수
var add = new Function("x", "y", "return x+y");

//4 arrow function
var add = (x, y) => x + y;

//*참고* 변수는 '선언'하고 함수는 '정의'한다

//8-4-1 함수선언문
function add(x, y) {
  return x + y;
}
//해당 함수 호출 법
console.log(add(2, 5)); // => 7
//함수 선언문은 함수 이름을 생략할 수 없다
// function (x, y) {
//   return x + y;
// } => Syntax Error

//함수 선언문은 표현식이 아닌 문이다
var add = function add(x, y) {
  return x + y;
};
// 위 문을 보면 함수 선언문이 변수에 할당 되는 것 처럼 보이지만 js엔진이 코드 문맥에 따라 함수 리터럴을 함수 선언문으로 해석하는 경우와
//함수 리터럴 표현식으로 해석하는 경우가 있기 때문
//자바스크립트엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고
//거기에 함수 객체를 할당한다. 함수는 함수 이름으로 호출하는 것이 아닌 함수 객체를 가리키는 시별자로 호출함

//var옆에 add는 식별자 function옆에 add는 함수 이름
var add = function add(x, y) {
  return x + y;
};
//콘솔로그 되는 add는 식별자
console.log(add(2, 4));

//8-4-2 함수 표현식
//자바스크립트의 함수는 값의 성질을 갖는 객체인 일급 객체이다 그러므로 함수는 함수 리터럴로 생성한 함수 객체를
//변수에 할당 할수 있다.이러한 방식을 함수 표현식이라고 한다
var add = function (x, y) {
  return x + y;
};
console.log(add(2, 6));

//함수 리터럴의 함수이름은 생략 가능하고 그를 익명 함수라고 한다
//기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};
console.log(foo(2, 3)); //=> Syntax Error foo is not defined

//8-4-3 함수 생성 시점과 함수 호이스팅

console.dir(add); //=> f add(x,y)
console.dir(sub); //=> undefined

console.log(add(2, 5)); //=> 7
console.log(sub(2, 5)); //=> Type Error: sub is not a function

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
//함수 선언문으로 정의한 함수(add)와 함수 표현식으로 정의한 함수(sub)의 생성 시점은 다르다
//함수는 호이스팅으로 인해 함수 선언문이 코드의 선두로 끌어 올려져 런타임 이전 js 엔진에 의해 먼저 실행된다
//그래서 함수 선언문(add)보다 이전에 함수를 참조해도 싫행이 가능하다

//함수와 변수 호이스팅은 미묘한 차이가 있는데
//변수는 undefined로 초기화 되고 함수 선언문의 식별자는 함수 객체로 초기화 된다

//함수 표현식은 변수에 할당 되는 값이 함수 리터럴인 문이다 그래서 변수 선언문과 변수 할당문을 한번에 동작시킨 것과
//같이 동작한다
// 따라서 함수표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다

//8-4-4 function 생성자 함수
//*생성자 함수*: 객체를 생성하는 함수
var add = new Function("x", "y", "return x+y");
//이는 일반적이지도 않고 바람직한 함수 생성방식이 아니므로 이런게 있다 정도로만 알자

//8-4-5 화살표 함수
//function 키워드 대신 arrow =>를 사용하는 방식
const add = (x, y) => x + y;
console.log(add(2, 1)); //=> 3
//이는 기존의 함수보다 표현만 간략한것이 아닌 내부 동작도 간략화 되어 있고 생성자 함수를 쓸수 없고 기존의 this바인딩과 방식도 다르다
//prototype 프로퍼티가 없으며 argument객체 또한 생성x

//8-5 함수호출
//함수는 함수() 방식으로 호출하고 ()안에 인수는 쉼표로 구분해서 나열한다
//함수를 호출하면 현재의 실행흐름을 중단하고 호출된 함수로 실행 흐름을 옮김
//그때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행

//8-5-1 매개변수와 인수
//함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 때 매개변수를 통해 인수를 전달함
//인수는 함수를 호출할때 지정하고 개수와 타입엔 제한이 없다
//매개변수는 함수 몸체 내부에서만 참조 가능하고 외부에선 참조 x
//또한 함수는 매개변수와 인수의 개수가 일치하는지 체크하지 않음 만약 인수의 개수가 부족해서 할당 되지않은 매개변수의 값은 undefined이다
//그렇다고 초과된 인수를 그냥 버리진 않음

//8-5-2 인수확인
//함수를 정의할 때 적절한 인수가 전달되었는지 확인 해야 오류를 예측할 수 있다
//하지만 ES6에 도입된 매개변수 기본값을 사용하면 인수 체크 및 초기화를 간소화 할 수 있따.
//ex)

function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}
console.log(add(1, 2, 3)); //6
console.log(add(1, 2)); //3
console.log(add(1)); //1
console.log(add()); //0

//8-5-3 매개변수의 최대 개수
//매개변수는 순서에 의미가 있어서 매개변수가 많아지면 함수 호출 시 인수의 순서를 고려해야한다 이는 함수의 사용법을 어렵게 만들고
//이는 곧 코드의 유지 보수성을 악화시킨다 고로 이상적인 함수는 한가지 일만 해야하고 가급적 작게 만들어야 한다
//그러므로 매개 변수도 최대 3개이상을 넘지 않도록 하는 것이 좋다
//만약 인수로 객체를 사용하면 매개변수의 순서나 코드의 가독성이 좋아지지만 전달된 객체를 함수 내부에서 변경하면 함수 외부에 있는
//객체가 변경되는, 부수효과가 발생한다

//8-5-5 반환문
//return키워드로 함수의 실행결과를 함수 외부로 반환한다
//이는 두가지 역할을 하는데
//1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다 고로 반환문 이후 문은 실행하지 않음
//2. 반환문은 return뒤의 표현식을 평가하기에 그 표현식을 명시적으로 지정하지 않으면 undefined
//반환문은 생략 할수 도 있고 return과 표현식 하이에 줄바꿈을 하면 예상치 못할 오류가 발생 할수 있어서 줄바꿈 x
//그리고 반환문은 함수 몸체 안에서만 쓸 수 있어서 함수 외부 전역에 쓰면 문법에러 발생

//8-6 참조에 의한 전달과 외부 상태의 변경
//객체 타입 인수는 원시값과 다르게 함수 몸체나 다른 참조 값을 통해서 객체를 변경하면 원본이 훼손된다. 즉 함수 외부에서 함수 몸체
//내부로 전달한 참조값에 의해 원본 객체가 변경되는 부수 효과가 발생한다
//이를 방지 하기 위한 방법으론 객체를 불변객체로 만들어서 변경 불가능한 값으로 만들거나
//객체릐 방어적 복사 혹은 깊은 복사를 통한 교체로 외부 상태가 변경되는 부수효과를 없앨 수 있다

//8-7 다양한 함수의 형태
//8-7-1 즉시 실행 함수
//즉시 실행 함수는 단한번만 호출되며 다시 호출할 수 없고 보통 익명함수를 사용하는 것이 일반적이며 반드시 그룹연산자(...)로 감싸야함
//그룹 연산자로 묶는 이유는 함수 리터럴을 평가해서 함수 객체를 생성하기 위함이다
//즉시 실행 함수도 일반 함수 처럼 값을 반환 할 수 있고 인수를 전달 할수도 있음
let res = (function () {
  var a = 3;
  var b = 3;
  return a + b;
})();
console.log(res); //=>9

res = (function (a, b) {
  return a * b;
})(3, 5);
console.log(res); //=>15

//8-7-2 재귀 함수
//함수가 자기 자신을 호출하는 것을 재귀 호출이라 하고 재귀 함수는 재귀 호출을 수행하는 함수이다
//그리고 이는 반복되는 처리를 위해 사용한다
function countDown(n) {
  for (let i = n; i >= onabort; i++) console.log(i);
}
countDown(10); //=> 10부터 0까지 출력하는 함수인데 이를 재귀 함수를 이용하면

function countDown(n) {
  if (n < 0) return;
  console.log(n);
  countDown(n - 1); // 이 부분이 재귀 호출
}
countDown(10); //위 문과 똑같이 실행
// 재귀함수를 이용하면 1부터 자신까지의 모든 양의 정수를 곱하는 팩토리얼 같이 귀찮은 작업을 간단히 구현할 수 있다

function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // => 이 부분이 재귀 호출
}
console.log(factorial(5)); // =>120
//재귀 함수는 자신을 무한 재귀 호출하기에 무조건 탈출조건을 만들어줘야 한다

//8-7-3 중첩 함수
//함수 내부에 정의된 함수를 중첩 혹은 내부 함수라고 한다 그리고 중첩 함수를 포함하는 함수는 외부 함수라고 한다
//중첩은 외부 함수 내에서만 호출 할수 있고 보통 중첩은 자신을 포함한 외부를 돕는 헬퍼 함수의 역할을 한다

//8-7-4 콜백 함수
// 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 하며 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달 받은
//함수를 고차 함수라고 한다 중첩함수가 외부 함수를 돕는 헬퍼함수의 역할을 하는 것 처럼 콜백도 고차에 전달 된어 헬퍼 역할을 한다
//단 중첩 함수는 고정되어서 교체하기 곤란하지만 콜백은 함수 외부에서 고차 내부로 주입하기 때문에 자유롭게 교체 할수 있다
//고차 함수는 콜백을 자신의 일부분으로 함성하고 매개변수를 통해 전달받은 콜백의 호출시점을 결정하고 호출하며
//콜백은 고차에 의해 호출되고 그때 고차는 필요에 따라 콜백에 인수를 전달 할수있다
//이는 함수형 프로그래밍 뿐만 아니라 비동기 처리(이벤트, ajax통신, 타이머 함수 등)에 활용되는 중요한 패턴이다 또한
//배열 고차 함수에서도 사용되는데 JS에서 배열은 사용빈도가 매우 높고 배열을 다룰때 배열 고차 함수는 매우 중요하다

//8-7-5 순수 함수와 비순수 함수
//함수형 프로그래밍에서 어떠한 외부상태에 의존하거나 변경하지 않는, 부수 효과가 없는 함수를 순수 함수라고 하고
//그 반대를 비순수 함수라고 한다
//순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하고 일반적으로 최소 하나 이상의 인수를 전달 받는다 그리고 이 함수의
//또다른 특징은 함수의 외부 상태를 변경하지 않는다

var count = 0;
//순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값 반환
function increase(n) {
  return n++;
}
count = increase(count);
console.log(count); //1
count = increase(count);
console.log(count); //2

var count = 0;
//비순수 함수
function increase() {
  return ++count;
}
//비순수 함수는 외부 상태(count)를 변경하므로 상태 변화 추척이 어렵다
increase();
console.log(count); //1
increase();
console.log(count); //2

//
//13 스코프
//

//13-1 스코프란?
//스코프는 우리말로 유효범위로 모든 프로그래밍 언어의 기본이며 중요한 개념이다 근데 JS의 스코프는 다른 언어의 것과는
//구별되는 특징이 주의가 필요하다 그리고 var let const로 선언한 변수의 스코프도 다르게 동작한다
//모든 식별자(변수, 함수, 클래스의 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조 할 수 있는 유효범위가 결정되고
//이를 스코프라고 하며 식별자가 유효한 범위라고 할 수 있다.

//13-2 스코프의 종류
//전역과 지역으로 나눌 수 있따

//13-2-1 전역과 전역스코프
//전역이란 코드의 가장 바깥 영역이고 전역 스코프를 만들며 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 되고 전역변수는
//어디서든 (함수내부에서도) 참조 할 수 있다.

//13-2-2 지역과 지역스코프
//지역은 함수 몸체 내부를 말하고 지역은 지역스코프를 만든다 지역 변수는 자신의 지역 스코프와 하위지역 스코프에서 유효하다
