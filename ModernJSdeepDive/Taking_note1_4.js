"use strict";
//1-1변수란?
//컴퓨터가 명령을 읽고 실행하기 위해 데이터를 저장한 임의의 메모리 주소
//*파싱: 컴퓨터가 실행문, 표현식을 해석하는 것/평가: 코드를 읽거나 계산하는 것*
//ex)
const result = 10 + 20;
//*10+20은 표현식*
//result가 변수이고 30은 변수 값이다 변수에 값이 대입되는 걸 할당이라고도 한다. *변수가 다른곳에 호출되는 것을 참조(reference)라고 한다

//1-2식별자란?
//변수가 데이터를 저장한 임의의 메모리 주소이자 이름이라고 하면
//식별자는 그 메모리 주소의 이름
//식별자는 변수보다 포괄적인 개념이고 그 식별자에는 변수 말고도 함수, 클래스 등이 있다

//1-3변수 선언이란?
//var, let, const가 있으며 변수를 사용하기 위해 필수적으로 선언을 해줘야 함
//변수를 선언한 후 할당을 하지 않으면 해당 메모리 공간, 변수는 비었을것 같지만 js에서는 암묵적으로 undefined를 초기화(값을 최초로 할당하는 것) 해서 넣어줌
//*만약 초기화 과정을 거치지 않으면 메모리 공간에 이전에 쓴 값이 남아있을 수 있는데 이를 쓰레기 값이라고 한다*

//1-4변수의 실행 시점?
//자바스크립트는 실행, 런타임 이전에 소스코드를 먼저 쭉 실행 하는데 그로 인해 변수 선언 이전에 변수 값을 참조하면 오류가 나지 않고 undefined가 호출
//ex)
console.log(score); //undefined
var score;
//이는 자바스크립트의 고유의 특징으로 변수 호이스팅이라고 함

//1-5값의 할당과 재할당
//ex)
var number = 10; //값(number)의 할당
console.log(number); //  10

var number = 20; //값(number)의 재할당
console.log(number); //   20

const num = 10; //const는 상수로 할당된 값을 수정하지 않음
// const num=20; = 고로 재 할당 불가능

//*가비지콜랙터: 할당된 값들이 주기적으로 검사를 해서 더이상 쓰이지 않는(어떤 식별자도 참조하지 않는 메모리 공간) 것들을 의미 *

//1-6식별자 네이밍 규칙
//식별자들이 쓰면 안되는 이름들이 있음
//ex await, break, case, catch, class, const, continue, debugger, default... etc

//*네이밍 컨벤션: 가독성 좋게 만든 식별자들*
//ex) 1.camelCase(ex.firstName) 2.snake_case(ex.first_name)

//
//2-1값이란?
//
//값은 식or표현식이 평가되어 생성된 결과

//2-2리터럴이란?
//사람이 이해할 수 있는 문자 또는 미리 약속한 기호로 표기한 코드
//ex) 정수(int), 문자(string), 참 거짓 (boolean), null, 객채(object),  배열(array)

//2-3표현식이란?
//값으로 평가(해석, 읽을)될 수 있는 문(statement)/표현식이 평가되면 새로운 값을 만들거나 기존의 값을 참조
//ex)
// const score = 50 + 50;
//여기선 50+50이 표현식/값으로 평가 될수 있는 문은 전부 표현식

//2-4 문이란?
//문은 프로그램을 실행하는 최소의 실행 단위이고 여러 토큰으로 구성됨
//*토큰이란 문법적 의미를 가진 것중에 더이상 나눌 수 없는 최소의 기본요소들*
//ex
const sum = 1 + 2; //이 한문장이 문이자 명령문이고 const/sum/=/1/+/2 전부다 토큰으로 분류

//2-5 표현식이 아닌 문
//표현식인 문과 그렇지 않은 문을 구분하는 법은 변수에 할당
//ex
// var foo = var x; => var x는 표현식이 아니기에 값처럼 사용불가

//
//3 데이터 타입?
//

//타입의 종류 - 원시 타입 / 객채 타입
//원시 타입 = number / string / boolean / undefined / null / symbol

// 1.nunmber : js는 c와 java와는 다르게 정수, 실수에 대한 구분이 없음
//실수 = 정수이고 정수 = 실수이다
//ex)
console.log(1 === 1.0); // true
console.log(4 / 2); // 2
console.log(3 / 2); // 1.5

//2.string : '', "", `` 안에 텍스트를 써서 표시함  ''와 ""는 띄어쓰기 줄바꿈 인식 불가
//따옴표 안에 다른 따옴표로 표기하면 문자열로 인식
//ex
console.log('Hi "I" am a human');
console.log("Hi 'I' am a human");
// ``string : '' "" 과는 다르게 띄어쓰기 줄바꿈을 인식함
//3.불리언 타입 : true false

//4.undefined : 변수 선언 후 값을 할당하지 않고 참조하면 뜸

//5.null : 의도적 부재, 아무내용도 할당되지 않음

//6. symbol : 변경 불가능한 원시타입의 값. 다른 값과 중복되지 않는 유일무이한 값

//객채 타입 = 앞선 6개의 타입 이외의 값이 전부 객채타입

//데이터 타입의 필요성?
//자바스크립트 엔진은 값의 데이터 타입에 따라 확보해야할 메모리 공간의 크기가
//결정됨 또한 값을 참조하기 위해 메모리의 바이트 수를 알아야 한다
//만약 let score = 100;이라면 변수 score를 숫자 타입으로 인식하고 이를 참조
//하면 8바이트 단위의 메모리 공간에 저장된 값을 읽어들임

//데이터 타입에 의한 값 해석
//메모리에 저장된 값 0100 0001은 숫자로 65이고 문자로는 A이다
//score 변수에 할당된 값은 숫자 이고 score변수를 참조하면 메모리의 2진수를
//숫자로 해석함

//데이터 타입이 필요한 이유
//1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
//2. 값을 참조 할때 한 번에 읽어들여야할 메모리 공간의 크기를 결정하기 위해
//3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

//정적 타입언어
//c나 자바 같이 값, 데이터의 타입을 먼저 선언하고 변수를 선언하는것
//ex) char c; int num = 9;
//정적 타입 언어에서 타입체크로 미리 선언된 타입이 데이터와 다를 경우 에러가 나면서
//실행이 중지 됨 이는 일관성을 강제한 대신 안정적인 코드를 구현하게 함

//동적 타입언어
//자바스크립트는 동적 타입의 언어로 데이터의 타입을 먼저 선언하지 않고 사용
//typeof 연산자로 변수를 선언해 보면

let foo;
console.log(typeof foo); //undefined

foo = 3;
console.log(typeof foo); //3 num

foo = "hi";
console.log(typeof foo); //'hi' string

foo = true;
console.log(typeof foo); //true boolean

foo = null;
console.log(typeof foo); //  object

foo = Symbol(); //  symbol
console.log(typeof foo); //  symbol

foo = {}; //객채
console.log(typeof foo); // object

foo = []; //배열
console.log(typeof foo); // object

foo = function () {}; //함수
console.log(typeof foo); //function

//이처럼 자바스크립트는 변수의 타입을 자유로이 변경 할수 있으며
//자바스크립트의 변수는 할당에 의해 타입이 결정되는 타입추론이라 하고
//언제든지 재할당에 의해 변수의타입이 변경될 수 있다
//다만 동적 타입의 단점은 유연성이 높은만큼 떨어지는 신뢰성이다

//동적에서 변수 사용시 주의 사항
//1.변수는 꼭 필요한 경우에 한해 제한적으로 사용 동적 타입의 유연한 성격 때문에
//타입을 잘못 예측해 오류날 확률이 높다
//2.변수의 유효범위(스코프)는 최대한 좁게 만들어야 함
//3.전역변수를 최대한 자제하자
//4.변수보다 상수(const)를 자주 사용하자
//5.변수의 목적이나 의미에 맞게 네이밍을 잘하자
// 좋은 코드는 가독성이 좋은 코드이다

//
//4 연산자?
//

//연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수
//연산을 수행해 하나의 값을 만들고 그 대상은 피연산자이다
//종류 => 산술, 문자열 연결,할당(=), 비교(<,>), 논리(&&),
//타입 (typeof)

//피 연산자가 값이라는 명사라면 연산자는 피 연산자를 연산하여 새로운 값을 만드
//는 동사 역할이다.

//4-1 산술 연산자: +, -, *, %, /
//4-1-1 단항 산술연산자: ++(증가), --(감소)
//++증가연산자: 피연산자의 값을 변경하는 암묵적 할당이 이뤄짐
//선 할당 후 증가

var x = 5;
result = x++;
console.log(result, x); // 5,6
//선 증가 후 할당
result = ++x;
console.log(result, x); // 7,7
//선 할당 후 감소
result = x--;
console.log(result, x); // 7,6
//선 감소 후 할당
result = --x;
console.log(result, x); // 5,5

//숫자 타입이 아닌 값에 단항 연산자를 실행할 경우 암묵적 타입변환이 이뤄진다
x = 1;

//문자열을 숫자로 타입 변환한다.
console.log(+x); // 1
//부수효과는 없음  *부수효과란 변환된 타입이 일시적일 뿐 다시 참조하거나 호출하면 기존에 정한 타입으로 회귀함
console.log(x); // '1'

//불리언 값을 숫자로 타입변환한다.
x = false;
console.log(+x); //0
//부수 효과x
console.log(x); //false

//문자열을 숫자로 타입 변환 할 수 없으므로 NaN을 반환한다
x = "Hello";
console.log(+x); // NaN
//부수 효과x
console.log(x); //"Hello"

//4-1-2 문자열 연결 연산자
// +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작

//문자열 연결 연산자
"1" + 2; // ->'12'
1 + "2"; // ->'12

//산술 연산자
1 + 2; // ->3

//true는 1로 타입변환
1 + true; // -> 2

//false는 0으로 타입변환
1 + false; // -> 1

//null은 0으로 타입변환
1 + null; // -> 1

//undefined는 숫자로 타입변환하지 않음
+undefined; // -> NaN
1 + undefined; // -> NaN
//true는 연산을 하면 개발자의 의도와 다르게 암묵적으로 타입변환, 강제로 변환한다

//4-2 할당 연산자
var x;
x = 10;
console.log(x); // 10

x += 5; // x= x+5
console.log(x); // x=15

x -= 5; // x= x-5
console.log(x); // x=10

x *= 5; // x=x*5
console.log(x); // 50

x /= 5; // x = x/5
console.log(x); // 10

x %= 5; // x = x%5
console.log(x); // 0

var str = "My Name is";
str += "lee"; // str = str + 'lee'
console.log(str); // 'My name is lee'

//할당문은 변수에 값을 할당하고 값으로 평가되지 않을것 같지만
//할당문은 값으로 평가되는 표현식인 문이며 물론 할당된 값으로도 평가된다

//4-3 비교연산자
//4-3-1 동등 일치 비교 연산자
//== 동등 비교 / x == y / x와y의 값이 같음
//=== 일치 비교/ x===y/ x와y의 값과 타입이 같음
//!= 부동등 비교/ x != y/ x와y의 값이 다름
//!=== 불일치 비교/ x !===y/ x와 y의 값과 타입이 다름

//==은 암묵적 타입변환을 거친 값들을 비교한다 그래서
// 5=='5'를 참으로 본다
// '0' ==''; -> false
// 0 ==''; -> true
//false =='false'; -> false
//false =='0'; -> true
//false == null; -> false
//이 처럼 동등비교 ==는 예측하기 힘들기에 일치 비교인 ===를 써야한다
// ===의 예시
// 5 === 5; 참
// 5=== '5'; 거짓
// NaN === NaN; 거짓 -> NaN은 자신과 일치하지 않는 유일한 값이기 때문
// 따라서 NaN이 숫자인지 조사하려면 Number.isNaN을 써야함
Number.isNaN(NaN); // = true
Number.isNaN(10); // =false
Number.isNaN(1 + undefined); // = true

//Object.is 메서드 => ES6에 도입된 이 메서드는 예측 가능한 정확한 비교를 함
//ex -0 === +0; => true
Object.is(-0, +0); // = false
NaN === NaN; //= false
Object.is(NaN, NaN); // =true

//부동등(!==) 과 불일치(!===) 비교 연산자들은 동등, 일치 비교 연산자와 반대

//4-3-2 대소 관계 비교 연산자
//종류: > , < , >= , <=

//4-4 삼항 조건 연산자
//조건식의 평가 결과에 따라 반환할 값을 결정함
//ex) 조건식 ?  a : b ; 조건식이 참이면 a 아니면 b
//if문처럼 쓸 수 있지만 if문과 달리 삼항 조건 연산자는 값처럼 사용할 수 있음
//ex) 
var x = 2;
var rst = x%2 ?  '홀수' : '짝수'
console.log(rst)// 짝수 2%2의 나머지는 0이고 0은 거짓

//4-5 논리연산자
// 우항, 혹은 좌항의 피연자를 논리 연산함
//ex) || = 논리합(or) , && = 논리곱(and) , !(부정not)
// ||: a||b a와 b 둘중에 하나라도 참이면 참

// &&: a&&b a와 b 둘 다 참이여야 참

// !: ex) !true = false , !false = true !옆의 불리언값을 전환 하고
// !옆에 불리언 값이 아닌 걸 써도 암묵적 타입변환으로 사용가능

//4-6 쉼표 연산ㅅ자
//쉼표(,) 연산자는 왼쪽 피연산자 부터 차례대로 피연산자를 평가하고 마지막 피연산
//자 까지의 평가 결과를 반환함

//4-7 그룹연산자
//소괄호()로 피연산사를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다
//괄호를 써서 수학처럼 연산자의 우선순위를 조절할 수 있다
//ex) 10*2+3;// = > 23  / 10*(2+3); // = > 50

//4-8 typeof 연산자
//typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환 "string" ,"number","boolean",
//"undefined", "symbol","object","function" 중 하나를 반환 null 은 반환하지 않고
//function은 함수로 반환
//ex)
typeof ""; //-> string
typeof 1; //-> number
typeof NaN; // -> number
typeof true; // ->boolean
typeof undefined; // -> undefiend
typeof Symbol(); // -> symbol
typeof null; //-> object
typeof []; //-> object
typeof {}; //-> object
typeof new Date(); // -> object
typeof /test/gi; // -> object
typeof function(){};// -> function

//null은 null이지만 typeof를 실행하면 오브젝트가 나온다 이는 자스의 버그이며 현재는
//기존 코드에 영향을 줄 수 있어 고치고 있지 않다
// 고로
var fooo= null;
null = typeof fooo; // false
null===fooo; // true
//또한 선언하지 않은 식별자를 typeof 연산을 하면 undefined가 뜸

//4-9 지수 연산자
// 2**2 를 하면 앞의 2가 밑으로 뒤의 2가 지수가 되어 2의 2승이 된다
//2**2.5는 2의 2.5승
//ES6 업데이트 이전에는 Math.pow()사용
//Math.pow(2,2) = 4 / 2의 2승
//Math.pow(2,4) = 16 /2의 4승
// 대신 이 ** 지수연산자는 우항부터 계산
//2**3**2는 64가 아니라 3**2. 3의 2승인 9를 2**9로 넘어가서 2의9승인 512가 나온다
// 또한 음수를 거듭제곱의 밑으로 쓰려면 괄호를 묶어야함
//ex) (-5)**2 => 25
//또한 이항 연산자 중에서 우선순위가 가장 높다
// ex) 2*3**2 => 18

//4-10 연산자의 부수효과
//대부분의 연산자는 다른 문에 영향을 주지 않지만 할당연산자(=)와 증가/감소연산자(++,--)
//와 delete연산자가 있다

//var x;

//x=1; 할당 연산자는 변수 값이 변하는 부수효과가 있디. 이는 x 변수를 
//사용하는 모든 다른 코드에 영향을 준다
//console.log(x)

//증가/감소연산자 역시 변수의 값이 변하는 부수 효과가 있고
//피연산자 x의 값이 재할당돼 x변수를 사용하는 다른 모든 코드에 영향을 준다
//var x=5;
//console.log(x++);

//4.11 연산자 우선순위
// 우선순위 순 1.() 2.new(매개변수), [](프로퍼티 접근), ()(함수), ?.(옵셔널 체이닝 연산자)
//3. new() 4.x++,x-- 5. !x,+x,-x,++x,--x typeof, delete 6.**(이항 연산자중 최고)
//7. *,/,%  
//8.+,- 
//9.<,<=,>,>=,in,instanceof 
//10. ==,!=,===,!==
//11.??(null병합 연산자)
//12.&&  13.|| 14.?...:... 15.할당 연산자(=,+=,-=,...) 16.,

