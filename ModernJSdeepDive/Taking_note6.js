//
//6 객체 리터럴
//

//6-1 객채란?
//자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 "모든것"이
//객채이고 원시값을 제외한 나머지 값은 모두 객체이다

//원시타입은 단 하나의 값만 나타내지만 객채 타입은 다양한 타입의 값(원시 혹은 다른객채들)
//이 하나의 단위로 구성된 복합적 자료구조이다
//또한 원시 값은 변경 불가능한 값이지만 객채 타입, 객채는 변경 가능한 값이다

//* 객채는 0개 이상의 프로퍼티들로 구성된 집합이고 프로퍼티는 키와 값으로 구성됨

//객체의 예)
var peson = {
  name: "kim", //프로퍼티
  age: 23, //프로퍼티
}; // name , age = 프로퍼티 키
// "kim", 23  = 프로퍼티 값

// 자바스크립트에서 사용 가능한 모든 값은 프로퍼티 값이 될 수 있다 자바스크립트의 함수는
//일급객채이므로 값으로 취급 되며 함수도 프로퍼티 값으로 사용가능하다
//프로퍼티의 값이 함수일 경우 일반 함수와 구분하기 위해 그를 메서드라고 부른다

//*일급객채란? : 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체
// 일급객체 조건 : 변수에 할당 할수 있다/ 다른 함수를 인자로 전달 받는다/ 다른 함수의 결과
//로서 리턴 될 수 있다
//ex)
var counter = {
  num: 0, //-> 프러퍼티
  increase: function () {
    this.num++;
  },
  //increase() -> 메서드
};
//이처럼 프로퍼티는 객채의 상태를 나타내는 값이고
//메서드는 프로퍼티(상태 데이터)를 참조하고 조작 할 수 있는 동작(behavior)
//이렇게 객체는 프로퍼티와 메서드를 모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위
//로 구조화 할 수 있어 유용하다
//이런 객체의 집합으로 프로그램을 표현하는 패러다임을 객체지향 프로그래밍이라한다

//6-2 객체 리터럴에 의한 객체 생성
//c++이나 자바 같은 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new
//연산자와 함께 생성자를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.

//*인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체. 객체지향 프로그래밍에서 객체는
//클래스와 인스턴스를 포함한 개념이고 클래스는 인스턴스를 생성하기 위한 템플릿의 역할

//자바스크립트는 프로토타입 기반 객체지향언어로서 클래스 기반 객체지향 언어와는 달리 다양한
//객체 생성 방법을 지원한다. -객체 리터럴- -object 생성자 함수- -생성자 함수-
//-object.create 메서드- -클래스-
// 이 5개 중 가장 일반적이고 간단한 방법은 객체 리터럴이다. 리터럴은 사람이 이해할 수 있
//는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이고 객체 리터럴은 객체를 생성하기
//위한 표기법이다.

//객체 리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당되는 시점에 자바스크
//립트 엔진은 객체 리터럴을 해석해 객체를 생성한다

var person = {
  name: "lee",
  sayHello: function () {
    console.log(`Hello my name is ${this.name}!`);
  },
};
console.log(person); //-> {name:"lee", sayHello:f}
console.log(typeof person); //-> object

//만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다

var empty = {};
console.log(empty); //-> ''(빈 객체)
console.log(typeof empty); //-> object
//객체 리터럴의 중괄호는 코드블록을 의미하지 않음. 코드 블록의 닫는 중괄호 뒤에 세미콜론을 붙이지 않지만
//객체 리터럴은 값으로 평가되는 표현식이기에 객체리터럴의 닫는 중괄호 뒤에 세미콜론을 붙임

//객체리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성방식
//객체를 생성하기 위해 클래스, new 연산자와 함께 먼저 정의하거나 생성할 필요가 없음
//숫자 값이나 문자열을 만드는 것과 유사하게 리터럴로 객체를 생성함
//객체 리터럴에 프로퍼티를 포함시켜 객체를 생성함과 동시에 프로퍼티를 만들 수도 있고
//객체를 생성한 이후에 프로퍼티를 동적으로 추가 할 수도 있다
//객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해 객체를 생성한다.

//6-3 프로퍼티란?
//객체는 프로퍼티의 집합이며 프로퍼티는 키와 값으로 구성됨

var person = {
  //프로퍼티 키는 name, 프로퍼티 값은 'lee'
  name: "Lee",
  // 프로퍼티 키는 age, 프로퍼티 값은 20
  age: 20,
};
//프로퍼티를 나열 할 때는 쉼표로 구분한다.일반적으로 마지막 프로퍼티 뒤에 쉼표를 쓰지 않으나 써도 된다
//프로퍼티의 키와 값으로 쓰일수 있는 값들은
//프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌값
//프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

//프로퍼티 키는 프로퍼티 값에 접근 할수 있는 이름으로 식별자 역할을 한다. 하지만 반드시 식별자 네이밍규칙을
//따라야 하는 것은 아니지만 식별자 네이밍 규칙을 준수하는 프로퍼티키와 그렇지 않은 프로퍼티키는 약간의 차이다 있다

//심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. 이때 프로퍼티 키는 문자열이므로 따옴표로 묶어여 한다.
//하지만 식별자 네이밍 규칙을 준수하는 이름인 경우 따옴표를 생략할수 있다.
//즉 식별자 규칙을 따르지 않으면 따옴표를 붙여야 한다. 그러므로 식별자 네이밍 규칙을 잘따르자

var person = {
  fisrtName: "yusu",
  "last-name": "shin", //이렇게 쓰는데 따옴표를 붙이지 않으면 SyntaxError: unexpected token오류 발생
};
console.log(person); // -> {firstName: 'yusu', last-name:'shin'}

//문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다. 이 경우에는 프로퍼티
//키로 사용할 표현식을 대괄호로 묶어야 한다.
var obj = {};
var key = "hello";

obj[key] = "world";
//var obj = {[key]:'world'};
console.log(obj); //-> {hello:'world'}

//빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하진 않지만 권장하지 않는다
var foo = {
  "": "",
};
console.log(foo); //-> {'':''}
//프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입변환으로 문자열이 된다
//ex) 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환
var foo = {
  0: 1,
  1: 2,
  2: 3,
};
console.log(foo); //-> {0:1, 1:2, 2:3}
//var, function 같은 예약어를 프로퍼티 키로 사용해도 에러 발생 x 하지만 예상치 못한 에러가 발생 할 수 있으니 권장x

var foo = {
  var: "",
  function: "",
};
console.log(foo); //-> {var:'',function:''}

//이미 존재하는 프로퍼티키를 중복선언하면 나중에 선언한 프로퍼티로 덮어쓴다 이때 에러가 생기지 않으니 주의
var foo = {
  name: "kim",
  name: "lee",
};
console.log(foo); //-> {name:'lee'}

//6.4메서드란?
//자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있따 자바스크립트의 함수는 일급함수이므로 값으로 취급할구 있기에 프로퍼티
//값으로 사용 가능하다

//프로퍼티 값이 함수일 경우를 메서드라고 하고 메서드는 객체에 묶여 있는 함수이다
var circle = {
  radius: 5,
  getDiameter: function () {
    // -> method
    return 2 * this.radius; //-> this는 circle
  },
};
console.log(circle.getDiameter()); //-> 10

//6.5 프로퍼티 접근
//프로퍼티에 접근하는 방법은
//1. 마침표 프로퍼티 접근 연산자(마침표 표기법)
//2. 대괄호 프로퍼티 접근 연산자(대괄호 표기법)
//프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름이면 마침표
// 대괄호 표기법을 모두 사용할 수 있따.

//마침표 프로퍼티 접근 연산자 또는 대괄호 프로퍼티 접근 연산자의 좌측에는 객체로 평가되는 표현식을 기술함
//마침표 프로퍼티 접근 연산의 우측 또는 대괄호 프러퍼티 접근 연산자의 내부에는 프로퍼티 키를 지정함

var person = {
  name: "lee",
};
console.log(person.name); // lee
console.log(person["name"]); // lee
//대괄호 표기법의 경우 대괄포 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로감싼 문자열이여야함
//ex) console.log(person[name]) = > 오류 (ReferenceError:name is not defined) : 만약 객체에 존재하지 않는 프로퍼티에 접근하면 undefined가 뜨므로 주의하자
//ex) console.log(person.age) => undefined

//프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름이 아니면 반드시 대괄호 표기법 사용
//프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표 생략 가능 그 외에 대괄호 내에 들어가는
//프로퍼티 키는 반드시 따옴표로 감싼 문자열이여야함
var person = {
  "last-name": "shin",
  1: 10,
};
// person.'last-name': error
person.last - name; // browser : NaN, node.js : ReferenceError: name is not defined
person[last - name]; //-> Reference Error
person["last-name"]; // -> lee

//프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표 생략가능
// person.1;  // -> SyntaxError unexpected number
// person.'1'  -> SyntaxError unexpected string
person[1]; //-> 10:person[1] -> person['1']
person["1"]; //-> 10

//6-6 프로퍼티 값 갱신
//이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨
var person = {
  name: "lee",
};
//person 객체에 name프로퍼티가 존재하므로 name프로퍼티의 값이 갱신된다.
person.name = "kim";
console.log(person); // {name:'kim'}

//6-7 프로퍼티 동적 생성
//존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다
var person = {
  name: "lee",
};
//person 객체에는 age프로퍼티 x
//따라서 person 객체에 age프로퍼티가 동적으로 생성되고 값이 할당
person.age = 20;
console.log(person); //-> {name:'lee',age:20}

//6-8 프로퍼티 삭제
//delete 연산자는 객체의 프로퍼티를 삭제함. 이때 delete 연산자의 피연산자는 프로퍼티 값에
//접근 할 수 잇는 표현식이여야 한다. 만약 존재하지도 않는 프로퍼티를 삭제하면 아무런 에러없이 무시됨
var person = {
  name: "lee",
};
//동적 프로퍼티 생성
person.age = 26;
//객체에 새로운 프로퍼티를 넣었으므로 delete연산자로 age프로퍼티를 삭제할 수 있따
delete person.age;

//person객체에 address 프로퍼티가 존재하지 않으므로 delete연산자로 address 프로퍼티를 삭제할 수 없고
//에러도 나지 않는다
delete person.address;
console.log(person); //-> {name:'lee'}

//6-9 ES6에 추가된 객체 리터럴의 확장기능
//6-9-1 프로퍼티 축약표현
//객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성됨
//프로퍼티 값은 식별자 표현식 일 수도 있다
//ES5 예)
var x = 1,
  y = 2;
var obj = {
  x: x,
  y: y,
};
console.log(obj); //-> {x:1, y:2}

//하지만 ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때
//프로퍼티키를 생략 할수 있다 이때 프로퍼티 키는 변수 이름으로 자동생성된다

//ES6
var x = 1,
  y = 2;

const obj = { x, y };
console.log(obj); // {x:1, y:2}

//6-9-2 계산된 프로퍼티 이름
//문자열 또는 문자열로 타입 변환 할수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성 할 수도 있다
//단 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다. 이를 계산된 프로퍼티 이름이라고 한다

//ES5
var prefix = "prop";
var i = 0;
var obj = {};

//계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
console.log(obj); //-> {prop-1:1, prop-2:2, prop-3:3}

//ES6
const prefix = "prop";
let i = 0;

//객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};
console.log(obj); //-> {prop-1:1, prop-2:2, prop-3:3}

//6-9-3 메서드 축약표현
//ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당
var obj = {
  name: "lee",
  sayHi: function () {
    console.log("Hi!" + this.name);
  },
};
obj.sayHi(); //-> 'Hi! lee'

//ES6
const obj = {
  name: "lee",
  sayHi() {
    console.log("hi!" + this.name);
  },
};
obj.sayHi(); //-> 'hi! lee'

//
//7 원시 값과 객체의비교
//

//원시 타입의 값 즉, 원시값은 변경 불가능한 값이지만
//객체(참조) 타입의 값, 즉 객체는 변경 가능한 값이다
//원시값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값 저장 => 값에 의한 전달
//원시 값을 갖는 변수를 다른변수에 할당하면 원본의 원시 값이 복사되어 전달 => 값에 의한 전달(pass by value)
//이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사됨 => 참조에 의한 전달(pass by reference)

//7-1 원시값
//7-1-1 변경 불가능한 값이란?
//원시타입의 값,원시 값은 변경 불가능한 값이다 (읽기전용이기도 함)
//변경 불가능하다는 것은 변수가 아닌 값이 변경 불가능하다는 얘기
//변수는 언제든 재할당을 통해 변수 값을 변경할수 있음
//불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 없다

//7-1-2 문자열과 불변성
//원시 값인 문자열은 다른 원시 값과 비교했을 때 0개 이상의 문자로 이뤄진 집합이고 문자의 개수에 따라 필요한 메모리 공간의 크기가 결정된다
//반면 숫자는 1이나 1000000도 동일한 8바이트가 필요함

//ex)
var str2 = "Hello"; //=> 5개의 문자로 이뤄진 문자열

//*유사 배열 객체 : 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체
//문자열은 배열처럼 인덱스를 통해 각 문자에 접근하며 length 프로퍼티를 갖기에 유사배열 객체이며 for문으로 순회할 수 있다
// var str = 'string' // console.log(str[0]) => s // console.log(str.length) => 5 // console.log(tsr.toUpperCase()) => STRING

//7-1-3 값에 의한 전달

var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy); // 80

score = 100;

console.log(score); // 100
console.log(copy); // =80

score = 80;

console.log(score == copy); //=true
//하지만score변수와 copy변수의 값 80은 다른 메모리 공간에 저장된 별개의 값

var copy = score;
console.log(copy === score); // true

score = 100;
console.log(copy === score); // false
//score를 copy에 할당하기 전까진 score 변수의 값을 변경해도 copy 변수의 값에는 아무 영향 x
//변수에 값이 전달 되는 것이 아니라 메모리 주소에 값이 전달 되기 때문에 변수와 같은 식별자는 값이 아닌 메모리 주소를 갖고 있음

//7-2 객체
//객체는 프로퍼티의 개수가 정해져 있지 않고 동적으로 추가, 삭제 할 수 있고 프로퍼티 값에도 제약이 없다
//고로 객체에 미리 확보할 매모리 공간의 크기를 정할 수 없다
